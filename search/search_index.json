{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Preface","text":"LeetCode Solutions \ud83d\udca1 Solutions to LeetCode in C++17, Java, and Python. This repository aims to provide code with good readability and consistent style over various topics and embraces new standards."},{"location":"styleguide/","title":"Style Guide","text":"<p>This document is originally created by @walkccc and @hsins.</p> <p>For further reading, please see the definition of Convention over configuration in Wikipedia.</p>"},{"location":"styleguide/#disclaimer","title":"Disclaimer","text":""},{"location":"styleguide/#general","title":"General","text":"<ul> <li>In our coding convention, we use <code>lowerCamelCase</code> for both functions and   variables. While this may deviate from the rules laid out in the   Google C++ Style Guide   and   PEP 8 -- Style Guide for Python Code,   it is done to maintain consistency with the LeetCode OJ system, which employs   <code>lowerCamelCase</code> for over 99% of the time. Remember, the most important thing   is to be consistent at all times.</li> <li>In code snippets, import statements and brackets may be omitted for brevity   (arguably), but they should be retained in real-world coding situations for   clarity and maintainability.</li> </ul>"},{"location":"styleguide/#c","title":"C++","text":"<ul> <li>The code is only for demonstration and cannot be compiled.</li> <li>Explicitly declaring types such as <code>int</code>, <code>char</code>, and <code>string</code> is often   preferable over using the <code>auto</code> keyword introduced in C++ 11.</li> <li><code>#include</code> statements are omitted in code snippets for brevity.</li> <li>Understanding the difference between <code>size_t</code> and <code>int</code> is crucial when   traversing arrays in practical applications, as it can affect the outcome.</li> <li>Qualifying with <code>std::</code> prefix when accessing standard libraries is   recommended for readability and maintainability in real-world coding   situations, as it clearly indicates the source of the identifier being used.</li> </ul>"},{"location":"styleguide/#java","title":"Java","text":"<ul> <li>The code is only for demonstration and cannot be compiled.</li> <li>Explicitly declaring types such as <code>int</code>, <code>char</code>, and <code>String</code> is often   preferable over using the <code>var</code> keyword introduced Java 10.</li> <li><code>import</code> statements are omitted in code snippets for brevity.</li> </ul>"},{"location":"styleguide/#python","title":"Python","text":"<ul> <li>Private functions are prefixed with <code>_</code>, which may seem tedious. However, in   the real world, we use tools like Mypy,   Pytype, and   Pyre for static type checking.</li> <li>We pass the argument <code>--indent-size=2</code> to   autopep8 for a better viewing   experience.</li> <li><code>import</code> statements are omitted in code snippets for brevity.</li> </ul>"},{"location":"styleguide/#fundamental","title":"Fundamental","text":""},{"location":"styleguide/#rules","title":"Rules","text":"<ul> <li>Class: <code>UpperCamelCase</code></li> <li>Function: <code>lowerCamelCase</code></li> <li>Variable: <code>lowerCamelCase</code></li> <li>Constant: <code>kUpperCamelCase</code></li> </ul>"},{"location":"styleguide/#examples-in-c","title":"Examples in C++","text":"<pre><code>// Class\nclass MyClass { ... }\n\n// Function\nfunction myFunction() { ... }\n\n// Variable\nint myVariable;\n\n// Constant\nconstexpr int kMod = 1'000'000'007;\n</code></pre>"},{"location":"styleguide/#template","title":"Template","text":""},{"location":"styleguide/#rules_1","title":"Rules","text":"<ul> <li>There should only be one public function.</li> <li> <p>Declare the variables in the proper scope as slow as possible.</p> </li> <li> <p>Declare <code>const</code> variables as soon as possible.</p> </li> <li>Declare <code>ans</code> as soon as possible.</li> <li> <p>Since LeetCode is just an online judge system rather than a big project, we     don't scatter all variables in different sections. However, we still sort     the variables based on the time we first use each of them.</p> </li> <li> <p>Code section (there should be one blank line between each sections.)</p> </li> <li> <p><code>public</code></p> <ol> <li>boundary conditions</li> <li>initial variables</li> <li>There may be many kernels separated with one blank line, but there    shouldn't be any blank line in each kernel.</li> <li>return</li> </ol> </li> <li> <p><code>private</code></p> <ol> <li>private variables</li> <li>private function(s)</li> </ol> </li> </ul>"},{"location":"styleguide/#schematic-template","title":"Schematic Template","text":"<p>We use C++ to demonstrate the idea, and the same concepts apply to Java and Python as well.</p> <ul> <li>No blank lines between variables initialization.</li> <li>Blank one single line between each section. However, if there's no sec 12,   no blank line between sec 11 and sec 13.</li> <li>If the last statement is not a paragraph (<code>for</code> loop most of the case), then   no blank lines between it and the <code>return</code> statement.</li> </ul> <pre><code>class Solution {\npublic:\n// There should only be one public function.\nfunc() {\n// (sec 0) boundary conditions\n\n// (sec 1) initial variables\n//   (sec 10) constexpr/const (size/length)\n//   (sec 11) ans\n//   (sec 12) declaration &amp; operation\n//   (sec 13) purely declaration\n\n// (sec 2) kernels\n\n// (sec 3) modify original initial variables\n\n// (sec 4) kernels\n\n// (sec n) return\n}\n\nprivate:\n// private variables\n\n// private function(s)\nhelper() { ... }\n\ndfs() { ... }\n};\n</code></pre> <p>Example (873. Length of Longest Fibonacci Subsequence):</p> <ul> <li>code:</li> </ul> <pre><code>class Solution {\npublic:\nint lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) {\nconst int n = arr.size();\nint ans = 0;\nvector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 2));\nunordered_map&lt;int, int&gt; numToIndex;\n\nfor (int i = 0; i &lt; n; ++i)\nnumToIndex[arr[i]] = i;\n\nfor (int j = 0; j &lt; n; ++j)\nfor (int k = j + 1; k &lt; n; ++k) {\nconst int ai = arr[k] - arr[j];\nif (ai &lt; arr[j] &amp;&amp; numToIndex.count(ai)) {\nconst int i = numToIndex[ai];\ndp[j][k] = dp[i][j] + 1;\nans = max(ans, dp[j][k]);\n}\n}\n\nreturn ans;\n}\n};\n</code></pre> <ul> <li>code (explanation):</li> </ul> <pre><code>class Solution {\npublic:\nint lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) {\n// Only get the value of size or length\n//   when we use it twice or more times.\n// Add `const`, and separate this line from next section a blank line.\nconst int n = arr.size();\n// Declare the variables in the proper scope as slow as possible.\n//   Declare `ans` as soon as possible.\n//   General Order:\n//     ans -&gt; dp -&gt; STL -&gt; pointers (TBD)\n//\n//   Graph Order:\n//     ans -&gt; graph -&gt; inDegree -&gt; state -&gt; q -&gt; seen\nint ans = 0;\nvector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 2));\nunordered_map&lt;int, int&gt; numToIndex;\n\nfor (int i = 0; i &lt; n; ++i)\nnumToIndex[arr[i]] = i;\n\nfor (int j = 0; j &lt; n; ++j)\nfor (int k = j + 1; k &lt; n; ++k) {\nconst int ai = arr[k] - arr[j]; // use const\nif (ai &lt; arr[j] &amp;&amp; numToIndex.count(ai)) {\nconst int i = numToIndex[ai]; // use const\ndp[j][k] = dp[i][j] + 1;\nans = max(ans, dp[j][k]);\n}\n}\n\nreturn ans;\n}\n};\n</code></pre>"},{"location":"styleguide/#boundary-conditions","title":"Boundary Conditions","text":"<pre><code>// Linked-List\nif (l1 == nullptr &amp;&amp; l2 == nullptr) { ... }\nif (l1 != nullptr || l2 != nullptr) { ... }\n\n// String\nif (str.empty()) { ... }\nif (str.length() &lt;= 2) { ... }\n\n// Vector\nif (vec.size() &lt;= 2) { ... }\n</code></pre>"},{"location":"styleguide/#return-value","title":"Return Value","text":"<pre><code>return ans;\nreturn {};\n</code></pre>"},{"location":"styleguide/#data-structures","title":"Data Structures","text":"<pre><code>// C++\nunordered_set&lt;string&gt; seen;\nunordered_map&lt;char, int&gt; count; // numToIndex, prefixToIndex\nvector&lt;int&gt; count; // sometimes it's a better choice than `unordered_map`\nstack&lt;char&gt; stack;\nqueue&lt;TreeNode*&gt; q;\ndeque&lt;TreeNode*&gt; q;\nauto compare = [](const ListNode* a, const ListNode* b) {\nreturn a-&gt;val &gt; b-&gt;val;\n};\npriority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(compare)&gt; minHeap(compare);\n</code></pre> <pre><code>// Java\nSet&lt;String&gt; seen = new HashSet&lt;&gt;();\nMap&lt;Character, Integer&gt; count = new HashMap&lt;&gt;();\nint[] count = new int[n];\nDeque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); // Do not use Stack.\nQueue&lt;Integer&gt; q = new LinkedList&lt;&gt;();\nDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();\nQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);\n</code></pre> <pre><code># Python\nseen = set() # or wordSet = set() if you like\ncount = {}\ncount = collections.defaultdict(int)\ncount = collections.defaultdict(list)\ncount = collections.Counter()\nq = collections.deque([root])\nq = collections.deque([root])\nstack = []\nminHeap = []\n</code></pre>"},{"location":"styleguide/#two-pointers-sliding-windows","title":"Two Pointers / Sliding Windows","text":"<ol> <li>Always prefer to one character to represent index variables.</li> <li>Use <code>i</code>, <code>j</code>, <code>k</code> in the loop, in that order.</li> </ol> <pre><code>int i = 0;\nfor (const int num : nums) { ... }\n</code></pre> <pre><code>for (int i = 0, j = 0; i &lt; n; ++i) { ... }\n</code></pre> <pre><code>int k = 0;\nfor (int i = 0; i &lt; n; ++i)\nfor (int j = i; j &lt; n; ++j) { ... }\n</code></pre> <pre><code>int l = 0;\nint r = nums.size() - 1;\n</code></pre>"},{"location":"styleguide/#union-find","title":"Union Find","text":"<pre><code>class UnionFind {\npublic:\nUnionFind(int n) : count(n), id(n), rank(n) {\niota(begin(id), end(id), 0);\n}\n\nvoid unionByRank(int u, int v) {\nconst int i = find(u);\nconst int j = find(v);\nif (i == j)\nreturn;\nif (rank[i] &lt; rank[j]) {\nid[i] = id[j];\n} else if (rank[i] &gt; rank[j]) {\nid[j] = id[i];\n} else {\nid[i] = id[j];\n++rank[j];\n}\n--count;\n}\n\nint getCount() const {\nreturn count;\n}\n\nprivate:\nint count;\nvector&lt;int&gt; id;\nvector&lt;int&gt; rank;\n\nint find(int u) {\nreturn id[u] == u ? u : id[u] = find(id[u]);\n}\n};\n</code></pre>"},{"location":"styleguide/#graph-tree","title":"Graph / Tree","text":"<ul> <li>If a graph has a clear tree structure, we name it a <code>tree</code>. Otherwise, we name   it a <code>graph</code>.</li> <li>Always use <code>(u, v)</code> to represent an edge regardless what is stated in the   problem.</li> </ul> <pre><code>vector&lt;vector&lt;int&gt;&gt; graph(n);\n\nfor (const vector&lt;int&gt;&amp; edge : edges) {\nconst int u = edge[0];\nconst int v = edge[1];\ngraph[u].push_back(v);\ngraph[v].push_back(u);\n}\n</code></pre>"},{"location":"styleguide/#dijkstra","title":"Dijkstra","text":"<pre><code>void dijkstra(const vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, int src) {\nvector&lt;int&gt; dist(graph.size(), INT_MAX);\nusing P = pair&lt;int, int&gt;;  // (d, u)\npriority_queue&lt;P, vector&lt;P&gt;, greater&lt;&gt;&gt; minHeap;\n\nminHeap.emplace(0, src);\ndist[src] = 0;\n\nwhile (!minHeap.empty()) {\nconst auto [d, u] = minHeap.top();\nminHeap.pop();\nfor (const auto&amp; [v, w] : graph[u])\nif (d + w &lt; dist[v]) {\ndist[v] = d + w;\nminHeap.emplace(dist[v], v);\n}\n}\n}\n</code></pre>"},{"location":"styleguide/#binary-search","title":"Binary Search","text":"<ol> <li>Always prefer to one character to represent index variables.</li> <li>Always prefer to use <code>[l, r)</code> pattern.</li> </ol> <pre><code>int l = 0;\nint r = nums.size();  // or nums.size() - 1\n\nwhile (l &lt; r) {\nconst int m = l + (r - l) / 2;\nif (f(m))    // optional\nreturn m;  // optional\nif (g(m))\nl = m + 1;  // new range [m + 1, r)\nelse\nr = m;  // new range [l, m)\n}\n\nreturn l;  // nums[l]\n</code></pre>"},{"location":"styleguide/#listnode","title":"ListNode","text":"<pre><code>ListNode dummy(0); // allocated on stack instead of heap\n\nListNode* curr;\nListNode* prev;\nListNode* next;\n\nListNode* slow;\nListNode* fast;\n\nListNode* head;\nListNode* tail;\n\nListNode* l1;\nListNode* l2;\n</code></pre>"},{"location":"styleguide/#2d-vector-2-strings","title":"2D Vector / 2 Strings","text":"<pre><code>// 2D Vector\nconst int m = matrix.size();\nconst int n = matrix[0].size();\n\n// if there're two strings\nconst int m = str1.length();\nconst int n = str2.length();\n\n// if there's only a string\nconst int n = str.length();\n</code></pre>"},{"location":"styleguide/#traversing","title":"Traversing","text":"<pre><code>// vector&lt;int&gt; nums;\nfor (int i = 0; i &lt; nums.size(); ++i) { ... }\nfor (const int num : nums) { ... }\n\n// vector&lt;string&gt; words;\nfor (const string&amp; word : words) { ... }\n\n// string str;\nfor (int i = 0; i &lt; str.length(); ++i) { ... }\nfor (const char c : str) { ... }\n\n// unordered_set&lt;int&gt; numsSet;\nfor (const int num : numsSet) { ... }\n\n// structured binding\n// unordered_map&lt;char, int&gt; map;\nfor (const auto&amp; [key, value] : map) { ... }\n\n// ListNode* head;\nfor (ListNode* curr = head; curr; curr = curr-&gt;next) { ... }\n</code></pre>"},{"location":"styleguide/#others","title":"Others","text":"<ol> <li>Always prefer to use <code>str.length()</code> over <code>str.size()</code>.</li> <li>Always use camelCase nomenclature when not listed above.</li> </ol> <pre><code>// C++\nint currNum;\nint maxProfit;\nTreeNode* currNode;\n</code></pre> <ol> <li>When there's confliction in expression and function or reserved key word:</li> </ol> <pre><code>// C++\nmini, std::min()\nmaxi, std::max()\n</code></pre> <pre><code># Python\nmini, min\nmaxi, max\nsumm, sum\n</code></pre> <ol> <li>When there are two maps/stacks, use meaningful names.</li> </ol> <pre><code>// C++\nunordered_map&lt;char, int&gt; countA;\nunordered_map&lt;char, int&gt; countB;\n</code></pre> <ol> <li>When we need to count something, use <code>sum</code>, <code>count</code> and <code>total</code>, in that    order.</li> <li>Initialize vector with <code>0</code> or <code>false</code> implicitly.</li> <li><code>constexpr</code> is used if possible.</li> <li><code>const</code> is used if we get value of <code>size()</code> or <code>length()</code>.</li> <li><code>const auto</code> is used when we iterate through a <code>unordered_map</code> or <code>map</code>.</li> <li>Use <code>&amp;</code> whenever possible except <code>int</code> and <code>char</code> because reference typically    takes 4 bytes, while <code>int</code> takes 2/4 bytes and <code>char</code> takes 1 byte.</li> <li>Prefer to name variables in a \"adjective + noun\" order. For example,    <code>maxLeft</code> is better than <code>leftMax</code>.</li> <li>If a block is really small, for example, before a <code>bfs()</code> call, sometimes we    don't add extra blank lines.</li> </ol>"},{"location":"problems/0003/","title":"3. Longest Substring Without Repeating Characters","text":"<p>Longest Substring with At Most Two Distinct Characters | Longest Substring with At Most K Distinct Characters | Subarrays with K Different Integers | Maximum Erasure Value | Number of Equal Count Substrings | Minimum Consecutive Cards to Pick Up | Longest Nice Subarray | Optimal Partition of String</p>"},{"location":"problems/0003/#problem","title":"Problem","text":"<p>Given a string <code>s</code>, find the length of the longest substring without repeating characters. \u00a0 Constraints:</p> <ul> <li> <p><code>0 &lt;= s.length &lt;= 5 * 104</code></p> </li> <li> <p><code>s</code> consists of English letters, digits, symbols and spaces.</p> </li> </ul> Example 1Example 2Example 3 <pre><code>Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n</code></pre> <pre><code>Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n</code></pre> <pre><code>Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n</code></pre> <p>Complexity:</p> <ul> <li>Time complexity : O(n).</li> <li>Space complexity : O(n).</li> </ul>"},{"location":"problems/0003/#solution","title":"Solution","text":"C++JavaPython <pre><code>class Solution {\npublic:\nint lengthOfLongestSubstring(string s) {\nint ans = 0;\nvector&lt;int&gt; count(128);\n\nfor (int l = 0, r = 0; r &lt; s.length(); ++r) {\n++count[s[r]];\nwhile (count[s[r]] &gt; 1)\n--count[s[l++]];\nans = max(ans, r - l + 1);\n}\n\nreturn ans;\n}\n};\n</code></pre> <pre><code>class Solution {\npublic int lengthOfLongestSubstring(String s) {\nint ans = 0;\nint[] count = new int[128];\n\nfor (int l = 0, r = 0; r &lt; s.length(); ++r) {\n++count[s.charAt(r)];\nwhile (count[s.charAt(r)] &gt; 1)\n--count[s.charAt(l++)];\nans = Math.max(ans, r - l + 1);\n}\n\nreturn ans;\n}\n}\n</code></pre> <pre><code>class Solution:\n  def lengthOfLongestSubstring(self, s: str) -&gt; int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] &gt; 1:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n</code></pre>"},{"location":"problems/2514/","title":"2605. Count Anagrams","text":"<p>Group Anagrams | Count Ways to Build Rooms in an Ant Colony</p>"},{"location":"problems/2514/#problem","title":"Problem","text":"<p>You are given a string <code>s</code> containing one or more words. Every consecutive pair of words is separated by a single space <code>' '</code>. A string <code>t</code> is an anagram of string <code>s</code> if the <code>ith</code> word of <code>t</code> is a permutation of the <code>ith</code> word of <code>s</code>.</p> <ul> <li>For example, <code>\"acb dfe\"</code> is an anagram of <code>\"abc def\"</code>, but <code>\"def cab\"</code>\u00a0and <code>\"adc bef\"</code> are not.</li> </ul> <p>Return the number of distinct anagrams of <code>s</code>. Since the answer may be very large, return it modulo <code>109 + 7</code>. \u00a0 Constraints:</p> <ul> <li> <p><code>1 &lt;= s.length &lt;= 105</code></p> </li> <li> <p><code>s</code> consists of lowercase English letters and spaces <code>' '</code>.</p> </li> <li> <p>There is single space between consecutive words.</p> </li> </ul> Example 1Example 2 <pre><code>Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".\n</code></pre> <pre><code>Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string.\n</code></pre> <p>Complexity:</p> <ul> <li>Time complexity : O(n).</li> <li>Space complexity : O(n).</li> </ul>"},{"location":"problems/2514/#solution","title":"Solution","text":"PythonJavascript <pre><code>from collections import Counter\nfrom math import factorial\nclass Solution:\n\"\"\"\n    \"too hot\" =&gt; 3 x 6 =&gt; 18\n    \"\"\"\n    def countAnagrams(self, s: str) -&gt; int:\n        res = 1\n        for w in s.split(\" \"):\n            cnt, prem = Counter(w), factorial(len(w))\n            for rep in cnt.values():\n                prem = prem // factorial(rep)\n            res = res * prem % 1000000007\n        return res\n</code></pre> <pre><code>/**\n * still incorrect with large numbers...\n */\nvar countAnagrams = function (s) {\nfunction factorial(n) {\nif (n === 0 || n === 1)\nreturn 1;\nelse\nreturn n * factorial(n - 1);\n}\n// count of each word, too =&gt; {t: 1, o: 2}\nfunction helper(word) {\nconst count = {};\nconst n = word.length;\nfor (let i = 0; i &lt; n; i++) {\n(c = word[i]);\ncount[c] = (count[c] || 0) + 1\n}\nconst denomenator = Object.values(count).reduce((prod, x) =&gt; prod * factorial(x), 1);\nconst numerator = factorial(n);\nreturn BigInt(numerator) / BigInt(denomenator);\n}\nlet n = BigInt(1);\nconst MODULO = BigInt(1000000007);\ns.split(\" \").forEach(w =&gt; {\nconsole.log(helper(w));\nn *= helper(w);\n})\nreturn n % MODULO;\n};\n</code></pre>"}]}